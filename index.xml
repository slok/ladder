<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ladder docs</title>
    <link>https://themotion.github.io/ladder/index.xml</link>
    <description>Recent content on Ladder docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the BSD 3-clause &#39;New&#39; or &#39;Revised&#39; license</copyright>
    <lastBuildDate>Sat, 29 Apr 2017 09:18:33 +0000</lastBuildDate>
    <atom:link href="https://themotion.github.io/ladder/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quickstart</title>
      <link>https://themotion.github.io/ladder/introduction/quickstart/</link>
      <pubDate>Sat, 29 Apr 2017 09:18:33 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/introduction/quickstart/</guid>
      <description>

&lt;p&gt;Start making autoscalers in Ladder is very easy and fast, but if you haven&amp;rsquo;t crafted any before
you may feel that you don&amp;rsquo;t know where to start, this small tutorials will guide you so you understard
where to start and make your first autoscalers.&lt;/p&gt;

&lt;p&gt;All the tutorials will use the &lt;a href=&#34;https://hub.docker.com/r/themotion/ladder/tags/&#34;&gt;official Docker image&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;basic-tutorial&#34;&gt;Basic tutorial&lt;/h2&gt;

&lt;p&gt;For a basic tutorial we will keep it simple, a small autoscaler that will set machines on a &lt;a href=&#34;http://docs.aws.amazon.com/autoscaling/latest/userguide/AutoScalingGroup.html&#34;&gt;AWS ASG&lt;/a&gt;
based on the number of messages on a &lt;a href=&#34;https://aws.amazon.com/sqs/&#34;&gt;AWS SQS&lt;/a&gt; and aplying a constant factor.&lt;/p&gt;

&lt;h3 id=&#34;global-configuration-file&#34;&gt;Global configuration file&lt;/h3&gt;

&lt;p&gt;The first thing is to create &lt;code&gt;ladder.yml&lt;/code&gt; file, this file has Ladder&amp;rsquo;s global configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:
  warmup: 30s

autoscaler_files:
  - &amp;quot;/etc/ladder/cfg-autoscalers/tutorial1/*.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using default settings except the warmup, warmup setting will make that any of the autoscaler doesn&amp;rsquo;t do anything until that duration has passed.&lt;/p&gt;

&lt;p&gt;Also we point to the autoscaler configuration, in this case all the files that are on &lt;code&gt;tutorial1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;autoscaler-configuration-file&#34;&gt;Autoscaler configuration file&lt;/h3&gt;

&lt;p&gt;Now we will create our autoscaler file, note that you may have multiple autoscaler files, and also
multiple autoscalers per file, but for this example we&amp;rsquo;ll do it simple and use a single file and one
autoscaler.&lt;/p&gt;

&lt;p&gt;We will start creating the file block by block.&lt;/p&gt;

&lt;h3 id=&#34;autoscaler-global-settings&#34;&gt;Autoscaler global settings&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: basic_tutorial_autoscaler_sqs_asg
description: &amp;gt;
    basic tutorial autoscaler will set an AWS autoscaling group quantity based on the number of
    messages that an AWS SQS queue has at a given point aplying a constant factor
interval: 2m
scaling_wait_timeout: 3m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our autoscaler is called &lt;code&gt;basic_tutorial_autoscaler_sqs_asg&lt;/code&gt; and will run every &lt;code&gt;2m&lt;/code&gt; to check if it needs to upscale or downscale, as a security measure we apply a &lt;code&gt;3m&lt;/code&gt; timeout to the waiting time of the scaler when it decides to scale (an scaler waits until the scalation that has been applied has completed).&lt;/p&gt;

&lt;h3 id=&#34;autoscaler-input-settings&#34;&gt;Autoscaler input settings&lt;/h3&gt;

&lt;p&gt;In this case our autoscaler will have only one inputter to keep it simple. The inputter will return
the number of machines that wants based on an input, in our case the number of messages in a queue&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;inputters:
  - name: sqs_queue_basic_tutorial_job_number
    description: &amp;quot;Get quantity based on the messages on the queue aplying a constant factor&amp;quot;
    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.eu-west-1.amazonaws.com/xxxxxxxxxxx/basic-tutorial-queue&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;eu-west-1&amp;quot;
    arrange:
      kind: constant_factor
      config:
        factor: 20
        round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This inputter has 2 subblocks, a &lt;a href=&#34;https://themotion.github.io/ladder/blocks/gatherers/&#34;&gt;gantherer&lt;/a&gt; the one that gets the number of messages from the queue, and
an &lt;a href=&#34;https://themotion.github.io/ladder/blocks/arrangers/&#34;&gt;arranger&lt;/a&gt; the one that applies the logic to convert the number on messages quantity to number of machines
desired quantity.&lt;/p&gt;

&lt;p&gt;In this case we will get the number of messages from the queue (in AWS SQS is known as &lt;code&gt;ApproximateNumberOfMessages&lt;/code&gt;) and will apply to this number a constant factor of 20(simple division)
always rounding up. For example:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;messages&lt;/th&gt;
&lt;th&gt;machines&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5500&lt;/td&gt;
&lt;td&gt;275&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;54321&lt;/td&gt;
&lt;td&gt;2717&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;autoscaler-solver-settings&#34;&gt;Autoscaler solver settings&lt;/h3&gt;

&lt;p&gt;In this case as we only have on inputter the &lt;a href=&#34;https://themotion.github.io/ladder/blocks/solvers/&#34;&gt;solver&lt;/a&gt; block is not neccessary because we don&amp;rsquo;t have
the need to decide wich of the inputters will be the chosen one.&lt;/p&gt;

&lt;h4 id=&#34;autoscaler-filters-settings&#34;&gt;Autoscaler filters settings&lt;/h4&gt;

&lt;p&gt;We will apply 2 &lt;a href=&#34;https://themotion.github.io/ladder/blocks/filters/&#34;&gt;filters&lt;/a&gt; as a filter chain. They will take the result returned by the inputter and apply
the filters as a pipeline, first filter output will be the input of the next one and so on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 2m
        scale_down_duration: 10m

    - kind: limit
      config:
        max: 1000
        min: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters will be applied in the same order as defined in the configuration file, in this case first will
be applied the &lt;code&gt;scaling_kind_interval&lt;/code&gt; filter and then &lt;code&gt;limit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We set &lt;code&gt;scaling_kind_interval&lt;/code&gt;so we don&amp;rsquo;t have spikes of machines, this filter will wait a concrete duration
before letting us to scale up or down, in this case we will wait at least for &lt;code&gt;2m&lt;/code&gt; before scaling up (this can
be multiple iterations  of the autoscaler without doing nothing until it satisfies &lt;code&gt;2m&lt;/code&gt; in scale up mode). On the
other hand we have &lt;code&gt;10m&lt;/code&gt; to scale down, the same logic applies, it needs to be in scaling down mode for &lt;code&gt;10m&lt;/code&gt; at least. As you can see we scale up fast, but scale down slowly, this is a common practice so we use the scaled up power
in case a new spike comes, and also we don&amp;rsquo;t disturb our platform downscaling too fast.&lt;/p&gt;

&lt;p&gt;The next filter is the safety filter that &lt;strong&gt;always&lt;/strong&gt; should be set, is optional but you should set a limit.
In our case we want at least &lt;code&gt;2&lt;/code&gt; machines running always, and tops we want &lt;code&gt;1000&lt;/code&gt; (we don&amp;rsquo;t want our company die due to an AWS invoice!)&lt;/p&gt;

&lt;h3 id=&#34;autoscaler-scaler-settings&#34;&gt;Autoscaler scaler settings&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://themotion.github.io/ladder/blocks/scalers/&#34;&gt;scaler&lt;/a&gt; is the one that sets the quantity on the target, in our case an AWS ASG.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scale:
    kind: aws_autoscaling_group
    config:
      auto_scaling_group_name: &amp;quot;basic-tutorial-AMIAutoScalingGroup&amp;quot;
      aws_region: &amp;quot;eu-west-1&amp;quot;
      scale_up_wait_duration: 1m
      scale_down_wait_duration: 5s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our scaler will set &lt;code&gt;basic-tutorial-AMIAutoScalingGroup&lt;/code&gt; ASG as its target, it will wait &lt;code&gt;1m&lt;/code&gt; after scaling up before continuing with the next iteration and will wait &lt;code&gt;5s&lt;/code&gt; before downscaling, in other words, it waits
machines to spin up (not too much) and it doesn&amp;rsquo;t wait after start downscaling.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;ASG scaler will do its best so only scales down the machines next to the &lt;code&gt;1h&lt;/code&gt; of utilization (by default, it will wait every machine to be running for &lt;code&gt;50m&lt;/code&gt; at least), this is because AWS charges you per hour. ASG autoscaler wants to save you money!&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;putting-all-together&#34;&gt;Putting all together&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ladder.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:
  warmup: 30s

autoscaler_files:
  - &amp;quot;/etc/ladder/cfg-autoscalers/tutorial1/*.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;basic_tutorial.yaml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: basic_tutorial_autoscaler_sqs_asg
  description: &amp;gt;
    basic tutorial autoscaler will set an AWS autoscaling group quantity based on the number of
    messages that an AWS SQS queue has at a given point aplying a constant factor
  interval: 2m
  scaling_wait_timeout: 3m

  scale:
    kind: aws_autoscaling_group
    config:
      auto_scaling_group_name: &amp;quot;basic-tutorial-AMIAutoScalingGroup&amp;quot;
      aws_region: &amp;quot;eu-west-1&amp;quot;
      scale_up_wait_duration: 1m
      scale_down_wait_duration: 5s

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 2m
        scale_down_duration: 10m

    - kind: limit
      config:
        max: 1000
        min: 2

  inputters:
  - name: sqs_queue_basic_tutorial_job_number
    description: &amp;quot;Get quantity based on the messages on the queue aplying a constant factor&amp;quot;
    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.eu-west-1.amazonaws.com/xxxxxxxxxxx/basic-tutorial-queue&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;eu-west-1&amp;quot;
    arrange:
      kind: constant_factor
      config:
        factor: 20
        round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to run our autoscaler with AWS credentials:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run  \
  --rm -it \
  -v `pwd`/ladder.yml:/etc/ladder/ladder.yml \
  -v `pwd`/basic_tutorial.yml:/etc/ladder/cfg-autoscalers/tutorial1/basic_tutorial.yml \
  -e AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} \
  -e AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} \
  -p 9094:9094 themotion/ladder
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You can use &lt;code&gt;-dry.run&lt;/code&gt; flag to test it before autoscale nothing.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;It will wait the warmup before start running the autoscaler, you can access to its endpoints on port &lt;code&gt;9094&lt;/code&gt;, for example: &lt;a href=&#34;http://127.0.0.1:9094/check&#34;&gt;http://127.0.0.1:9094/check&lt;/a&gt; and it will give you information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;status&amp;quot;:&amp;quot;Ok&amp;quot;,
   &amp;quot;uptime&amp;quot;:&amp;quot;1m45.514659061s&amp;quot;,
   &amp;quot;check_ts&amp;quot;:&amp;quot;2017-04-29 08:56:35.267076739 +0000 UTC&amp;quot;,
   &amp;quot;version&amp;quot;:&amp;quot;Ladder version 0.1.0, build master(695fa7b)&amp;quot;,
   &amp;quot;healthy&amp;quot;:{  
      &amp;quot;ladder_autoscaler&amp;quot;:{  
         &amp;quot;basic_tutorial_autoscaler_sqs_asg&amp;quot;:&amp;quot;running&amp;quot;
      }
   },
   &amp;quot;unhealthy&amp;quot;:{  
      &amp;quot;ladder_autoscaler&amp;quot;:{  

      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it! now your platform is autoscaled. Easy right?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API</title>
      <link>https://themotion.github.io/ladder/operating/api/</link>
      <pubDate>Sun, 01 Jan 2017 11:08:00 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/operating/api/</guid>
      <description>

&lt;p&gt;Ladder API at this moment only has one version &lt;code&gt;v1&lt;/code&gt;, the default
entrypoint is &lt;code&gt;/api/v1&lt;/code&gt; but this can be configured.&lt;/p&gt;

&lt;h2 id=&#34;autoscalers&#34;&gt;Autoscalers&lt;/h2&gt;

&lt;p&gt;Autoscalers entrypoint are prefixed with &lt;code&gt;/autoscalers&lt;/code&gt;, this entrypoints have
the actions that can be executed on autoscalers&lt;/p&gt;

&lt;h3 id=&#34;list-autoscalers&#34;&gt;List autoscalers&lt;/h3&gt;

&lt;p&gt;This enpoint will return the present autoscalers and their state&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;path: &lt;code&gt;/autoscalers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;method: &lt;code&gt;GET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;request&#34;&gt;Request&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl http://ladder.host/api/v1/autoscalers
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;response&#34;&gt;Response:&lt;/h4&gt;

&lt;p&gt;Code: &lt;code&gt;200&lt;/code&gt;
Body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;autoscalers&amp;quot;:{  
      &amp;quot;asg1&amp;quot;:{  
         &amp;quot;status&amp;quot;:&amp;quot;running&amp;quot;
      },
      &amp;quot;asg2&amp;quot;:{  
         &amp;quot;status&amp;quot;:&amp;quot;running&amp;quot;
      },
      &amp;quot;asg3&amp;quot;:{  
         &amp;quot;status&amp;quot;:&amp;quot;stopped&amp;quot;
      },
      &amp;quot;asg4&amp;quot;:{  
         &amp;quot;status&amp;quot;:&amp;quot;running&amp;quot;
      }
   }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stop-autoscaler-for-a-period&#34;&gt;Stop autoscaler for a period&lt;/h3&gt;

&lt;p&gt;Autoscalers state should be running, so the concept or stop for ever is not valid on Ladder
this enpoint will stop a running autoscaler for a period of time (&lt;a href=&#34;https://golang.org/pkg/time/#ParseDuration&#34;&gt;golang duration format&lt;/a&gt; valid&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;path: &lt;code&gt;/autoscalers/{autoscaler_name}/stop/{duration}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;method: &lt;code&gt;PUT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example stop &lt;code&gt;render_instances&lt;/code&gt; autoscaler for 1:30h&lt;/p&gt;

&lt;h4 id=&#34;request-1&#34;&gt;Request&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -XPUT http://ladder.host/api/v1/autoscalers/render_instances/stop/1h30m
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;response-when-autoscaler-running&#34;&gt;Response when autoscaler running&lt;/h4&gt;

&lt;p&gt;Code: &lt;code&gt;202&lt;/code&gt;
Body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;autoscaler&amp;quot;:&amp;quot;render_instances&amp;quot;,
   &amp;quot;msg&amp;quot;:&amp;quot;Autoscaler stop request sent&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;response-when-autoscaler-already-stopped&#34;&gt;Response when autoscaler already stopped&lt;/h4&gt;

&lt;p&gt;Code: &lt;code&gt;409&lt;/code&gt;
Body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;data&amp;quot;:{  
      &amp;quot;autoscaler&amp;quot;:&amp;quot;render_instances&amp;quot;,
      &amp;quot;deadline&amp;quot;:1485267342,
      &amp;quot;msg&amp;quot;:&amp;quot;Autoscaler already stopped&amp;quot;,
      &amp;quot;required-action&amp;quot;:&amp;quot;Need to cancel current stop state first&amp;quot;
   },
   &amp;quot;error&amp;quot;:&amp;quot;Autoscaler already stopped&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;Deadline is UTC unix epoch&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;cancel-an-autoscaler-stop-action&#34;&gt;Cancel an autoscaler stop action&lt;/h3&gt;

&lt;p&gt;this enpoint will cancel the stop state of an autoscaler&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;path: &lt;code&gt;/autoscalers/{autoscaler_name}/cancel-stop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;method: &lt;code&gt;PUT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;request-2&#34;&gt;Request&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -XPUT http://ladder.host/api/v1/autoscalers/render_instances/cancel-stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;response-when-autoscaler-stopped&#34;&gt;Response when autoscaler stopped:&lt;/h4&gt;

&lt;p&gt;Code: &lt;code&gt;202&lt;/code&gt;
Body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;autoscaler&amp;quot;:&amp;quot;render_instances&amp;quot;,
   &amp;quot;msg&amp;quot;:&amp;quot;Autoscaler stop cancel request sent&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;response-when-autoscaler-running-1&#34;&gt;Response when autoscaler running:&lt;/h4&gt;

&lt;p&gt;Code: &lt;code&gt;400&lt;/code&gt;
Body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;data&amp;quot;:{  
      &amp;quot;autoscaler&amp;quot;:&amp;quot;render_instances&amp;quot;,
      &amp;quot;msg&amp;quot;:&amp;quot;Autoscaler is not stopped&amp;quot;
   },
   &amp;quot;error&amp;quot;:&amp;quot;Autoscaler is not stopped&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Using as a framework</title>
      <link>https://themotion.github.io/ladder/operating/framework/</link>
      <pubDate>Sun, 13 Nov 2016 18:02:45 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/operating/framework/</guid>
      <description>&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>https://themotion.github.io/ladder/operating/metrics/</link>
      <pubDate>Sun, 13 Nov 2016 18:02:22 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/operating/metrics/</guid>
      <description>

&lt;h2 id=&#34;prometheus&#34;&gt;Prometheus&lt;/h2&gt;

&lt;p&gt;Ladder serves prometheus metrics on &lt;code&gt;/metrics&lt;/code&gt; by default, you can override this
on the global configuration like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;metrics_path: /my/awesome/metrics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now this are the available metrics:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ladder_gatherer_quantity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_gatherer_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_gatherer_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_inputter_quantity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_inputter_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_inputter_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_solver_quantity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_solver_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_solver_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_current_quantity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_current_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_current_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_quantity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_scaler_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_autoscaler_iterations_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_autoscaler_errors_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_autoscaler_duration_histogram_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ladder_autoscaler_running&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;grafana-dashboard&#34;&gt;Grafana dashboard&lt;/h2&gt;

&lt;p&gt;With the metrics that Ladder exposes to Prometheus, using along with Grafana
you can have a very nice dashboard where you can see the state of Ladder.&lt;/p&gt;

&lt;p&gt;Here you can download the &lt;a href=&#34;https://themotion.github.io/ladder/data/ladder-dashboard.json&#34;&gt;dashboard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://themotion.github.io/ladder/img/grafana.png&#34; alt=&#34;Grafana dashboard&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuration</title>
      <link>https://themotion.github.io/ladder/operating/configuration/</link>
      <pubDate>Sun, 13 Nov 2016 18:02:13 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/operating/configuration/</guid>
      <description>

&lt;h2 id=&#34;configuration-schema&#34;&gt;Configuration schema&lt;/h2&gt;

&lt;p&gt;Ladder configuration is splitted in 2 main blocks, one the global configuration and
a multiple autoscalers blocks. The main entrypoint configuration of Ladder will point
to the other configuration files where the autoscalers are configured.&lt;/p&gt;

&lt;p&gt;For example our main configuration is &lt;code&gt;ladder.yml&lt;/code&gt; (by default will be this):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:
  metrics_path: /metrics
  api_v1_path: /api/v1
  interval: 30s
  warmup: 3m
  scaling_wait_timeout: 3m

autoscaler_files:
  - cfg-autoscalers/services/amis/*.yml
  - cfg-autoscalers/services/main_cluster/*.yml
  - cfg-autoscalers/clusters/*.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file points to our autoscalers that will reside there, see the file structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./ladder.yml
./cfg-autoscalers/
├── clusters
│   ├── main.yml
│   └── wrong.json
└── services
    ├── amis
    │   └── render.yml
    └── main_cluster
        ├── infra.yml
        └── video.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see the paths are path matchers, that &lt;code&gt;wrong.json&lt;/code&gt; will be ignored.&lt;/p&gt;

&lt;h2 id=&#34;global-configuration&#34;&gt;Global configuration&lt;/h2&gt;

&lt;p&gt;The global configuration is the configuration that will be applied to Ladder as
a program or by default to all the autoscalers depending on the setting&lt;/p&gt;

&lt;p&gt;It starts with &lt;code&gt;global:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;metrics_path&lt;/code&gt;: The path where the metrics can be retrieved, by default &lt;code&gt;/metrics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config_path&lt;/code&gt;: The path where the loaded configuration files can be retrieved, by default: &lt;code&gt;/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;health_check_path&lt;/code&gt;: The path where the health check will be listening, by default &lt;code&gt;/check&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;api_v1_path&lt;/code&gt;: The prefix path where the API v1 enpoints will be listening, by default &lt;code&gt;/api/v1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interval&lt;/code&gt;: The interval the autoscaler will run the iteration process, by default &lt;code&gt;30s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;warmup&lt;/code&gt;: The time the autoscaler will wait for the first scalation execution
(gathering, solving&amp;hellip; will occur), by default &lt;code&gt;30s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaling_wait_timeout&lt;/code&gt;: The time that will wait before giving timeout when a
correct scalation starts the process of waiting until the target has scaled &lt;code&gt;2m&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;autoscalers-cofiguration-files&#34;&gt;Autoscalers cofiguration files&lt;/h2&gt;

&lt;p&gt;Autoscaler configuration files have one or multiple autoscalers per file, thats up to you
and how do you organize the autoscalers. For example this could be a very simple autoscaling file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: autoscaler1
  description: &amp;quot;As1&amp;quot;

  scale:
    kind: aws_autoscaling_group
    config:
      aws_region: &amp;quot;us-west-2&amp;quot;
      auto_scaling_group_name: &amp;quot;slok-ECSAutoScalingGroup-1PNI4RX8BD5XU&amp;quot;

  inputters:
  - name: aws_sqs_constant_factor
    description: &amp;quot;Will get a number based on the queue messages and a constant factor division&amp;quot;
    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.us-west-2.amazonaws.com/016386521566/slok-render-jobs&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;us-west-2&amp;quot;

    arrange:
      kind: constant_factor
      config:
        factor: 10
        round_type: &amp;quot;ceil&amp;quot;
# Autoscaler 2
- name: autoscaler2
  description: &amp;quot;As2&amp;quot;

  scale:
    kind: aws_autoscaling_group
    config:
      aws_region: &amp;quot;us-west-2&amp;quot;
      auto_scaling_group_name: &amp;quot;slok-ECSAutoScalingGroup-1PNI4RX8BD5XU&amp;quot;

  inputters:
  - name: aws_sqs_constant_factor
    description: &amp;quot;Will get a number based on the queue messages and a constant factor division&amp;quot;
    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.us-west-2.amazonaws.com/016386521566/slok-render-jobs&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;us-west-2&amp;quot;

    arrange:
      kind: constant_factor
      config:
        factor: 10
        round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h2&gt;

&lt;p&gt;This is a real example of multiple autoscalers (services, clusters&amp;hellip;), the file structure is this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.
├── cfg-autoscalers
│   ├── factory
│   │   ├── analytics.yml
│   │   ├── processing.yml
│   │   ├── rendering.yml
│   │   └── transcoding.yml
│   └── infra
│       └── cluster.yml
└── ladder.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ladder-yml&#34;&gt;&lt;code&gt;ladder.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:
  metrics_path: /metrics
  interval: 30s
  warmup: 3m
  scaling_wait_timeout: 2m

autoscaler_files:
  - &amp;quot;cfg-autoscalers/factory/*.yml&amp;quot;
  - &amp;quot;cfg-autoscalers/infra/*.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cfg-autoscalers-infra-cluster-yml&#34;&gt;&lt;code&gt;cfg-autoscalers/infra/cluster.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: ECS_cluster
  disabled: false
  description: &amp;gt;
    ECS autoscaler will set the correct number of instances on an ECS autoscaling
    group based on the memory or cpu reserved percentage of that autoscaler cloudwatch
    metrics
  interval: 1m
  scaling_wait_timeout: 6m
  scale:
    kind: aws_autoscaling_group
    config:
      auto_scaling_group_name: &amp;quot;prod-ECSAutoScalingGroup-F4VEQM9FVL2U&amp;quot;
      aws_region: &amp;quot;eu-west-1&amp;quot;
      scale_up_wait_duration: 3m
      scale_down_wait_duration: 1m30s

  solve:
    kind: bound
    config:
      kind: max

  filters:
    - kind: ecs_running_tasks
      config:
        aws_region: eu-west-1
        cluster_name: prod-ECSCluster1-OIA8GT0KCY6X
        max_pending_tasks_allowed: 0
        max_checks: 10
        error_on_max_checks: true
        when: scale_down

    - kind: scaling_kind_interval
      config:
        scale_up_duration: 3m
        scale_down_duration: 6m

    - kind: limit
      config:
        max: 300
        min: 8

  inputters:
  - name: memory_reserved_based_input
    description: &amp;gt;
      This input will arrange the required number of instances on a cluster based
      on an ECS cluster memory reservation
    gather:
      kind: prometheus_metric
      config:
        addresses:
          - http://prometheus.prod.bi.themotion.lan
          - http://prometheus2.prod.bi.themotion.lan
        query: cluster:container_memory_remaining_for_reservation:bytes{type=&amp;quot;ecs&amp;quot;}
    arrange:
      kind: threshold
      config:
        scaleup_threshold: 16106127360
        scaledown_threshold: 48318382080
        scaleup_percent: 40
        scaledown_percent: 20
        scaleup_max_quantity: 10
        scaledown_max_quantity: 2
        scaleup_min_quantity: 1
        scaledown_min_quantity: 1
        inverse: true

  - name: cpu_reserved_based_input
    description: &amp;gt;
      This input will arrange the required number of instances on a cluster based
      on an ECS cluster cpu reservation
    gather:
      kind: prometheus_metric
      config:
        addresses:
          - http://prometheus.prod.bi.themotion.lan
          - http://prometheus2.prod.bi.themotion.lan
        query: cluster:container_cpu_remaining_for_reservation:cpu_shares{type=&amp;quot;ecs&amp;quot;}
    arrange:
      kind: threshold
      config:
        scaleup_threshold: 8192
        scaledown_threshold: 24576
        scaleup_percent: 40
        scaledown_percent: 20
        scaleup_max_quantity: 10
        scaledown_max_quantity: 2
        scaleup_min_quantity: 1
        scaledown_min_quantity: 1
        inverse: true

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cfg-autoscalers-factory-rendering-yml&#34;&gt;&lt;code&gt;cfg-autoscalers/factory/rendering.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: render_instances
  disabled: false
  description: &amp;quot;Render autoscaler will autoscale machines based on the SQS video rendering jobs&amp;quot;
  interval: 1m
  scaling_wait_timeout: 6m

  scale:
    kind: aws_autoscaling_group
    config:
      auto_scaling_group_name: &amp;quot;prod-ami-render-AMIAutoScalingGroup-1X8U7Q03UC4BC&amp;quot;
      aws_region: &amp;quot;eu-west-1&amp;quot;
      scale_up_wait_duration: 1m
      scale_down_wait_duration: 5s

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 30s
        scale_down_duration: 20m

    - kind: limit
      config:
        max: 2500
        min: 3

  inputters:
  - name: render_instances_based_on_jobs_queues
    description: &amp;quot;Get quantity based on the jobs length with a constant factor&amp;quot;

    gather:
      kind: prometheus_metric
      config:
        addresses:
          - http://prometheus.prod.bi.themotion.lan
          - http://prometheus2.prod.bi.themotion.lan
        query: number_pending_jobs{queue=&amp;quot;render&amp;quot;}
    arrange:
      kind: constant_factor
      config:
        factor: 5
        round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cfg-autoscalers-factory-processing-yml&#34;&gt;&lt;code&gt;cfg-autoscalers/factory/processing.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: processor_service
  disabled: false
  description: &amp;quot;Procesor service will autoscale instances based on the SQS processing jobs&amp;quot;
  interval: 30s
  scaling_wait_timeout: 5m

  scale:
    kind: aws_ecs_service
    config:
      aws_region: eu-west-1
      cluster_name: prod-ECSCluster1-OIA8GT0KCY6X
      service_name: processor

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 1m
        scale_down_duration: 5m

    - kind: limit
      config:
        max: 1000
        min: 2

  inputters:
  - name: service_instances_based_on_jobs_queue
    description: &amp;quot;Get quantity based on the jobs length with a constant factor&amp;quot;

    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.eu-west-1.amazonaws.com/843176375373/prod-processing&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;eu-west-1&amp;quot;
    arrange:
      kind: constant_factor
      config:
        factor: 10
        round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cfg-autoscalers-factory-transcoding-yml&#34;&gt;&lt;code&gt;cfg-autoscalers/factory/transcoding.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: transcoder_service
  disabled: false
  description: &amp;quot;Transcodder service will autoscale instances based on the SQS video rendering jobs&amp;quot;
  interval: 30s
  scaling_wait_timeout: 5m

  scale:
    kind: aws_ecs_service
    config:
      aws_region: eu-west-1
      cluster_name: prod-ECSCluster1-OIA8GT0KCY6X
      service_name: transcoder

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 1m
        scale_down_duration: 5m

    - kind: limit
      config:
        max: 800
        min: 2

  inputters:
  - name: service_instances_based_on_jobs_queue
    description: &amp;quot;Get quantity based on the jobs length with a constant factor&amp;quot;

    gather:
      kind: prometheus_metric
      config:
        addresses:
          - http://prometheus.prod.bi.themotion.lan
          - http://prometheus2.prod.bi.themotion.lan
        query: number_pending_jobs{queue=&amp;quot;transcode&amp;quot;}
    arrange:
      kind: constant_factor
      config:
        factor: 10
        round_type: &amp;quot;ceil&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cfg-autoscalers-factory-analytics-yml&#34;&gt;&lt;code&gt;cfg-autoscalers/factory/analytics.yml&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;autoscalers:
- name: analytics_mine_service
  disabled: false
  description: &amp;quot;Analytics Mine autoscales based on the number of import jobs present in the queue&amp;quot;
  interval: 30s
  scaling_wait_timeout: 5m

  scale:
    kind: aws_ecs_service
    config:
      aws_region: eu-west-1
      cluster_name: prod-ECSCluster1-OIA8GT0KCY6X
      service_name: analytics-mine

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 1m
        scale_down_duration: 5m

    - kind: limit
      config:
        max: 50
        min: 0

  inputters:
  - name: service_instances_based_on_jobs_queue
    description: &amp;quot;Get quantity based on the jobs length with a constant factor&amp;quot;

    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.eu-west-1.amazonaws.com/843176375373/prod-analytics-batches&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;eu-west-1&amp;quot;
    arrange:
      kind: constant_factor
      config:
        factor: 5
        round_type: &amp;quot;ceil&amp;quot;

- name: analytics_forge_service
  disabled: false
  description: &amp;quot;Analytics Forge autoscales based on the number of jobs in the queue&amp;quot;
  interval: 30s
  scaling_wait_timeout: 5m

  scale:
    kind: aws_ecs_service
    config:
      aws_region: eu-west-1
      cluster_name: prod-ECSCluster1-OIA8GT0KCY6X
      service_name: analytics-forge

  filters:
    - kind: scaling_kind_interval
      config:
        scale_up_duration: 1m
        scale_down_duration: 5m

    - kind: limit
      config:
        max: 5
        min: 1

  inputters:
  - name: service_instances_based_on_jobs_queue
    description: &amp;quot;Get quantity based on the jobs length with a constant factor&amp;quot;

    gather:
      kind: aws_sqs
      config:
        queue_url: &amp;quot;https://sqs.eu-west-1.amazonaws.com/843176375373/prod-analytics-jobs&amp;quot;
        queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
        aws_region: &amp;quot;eu-west-1&amp;quot;
    arrange:
      kind: constant_factor
      config:
        factor: 360
        round_type: &amp;quot;ceil&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Running</title>
      <link>https://themotion.github.io/ladder/operating/running/</link>
      <pubDate>Sun, 13 Nov 2016 17:54:56 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/operating/running/</guid>
      <description>

&lt;h2 id=&#34;configuration-file&#34;&gt;Configuration file&lt;/h2&gt;

&lt;p&gt;When you run ladder by default will load &lt;code&gt;ladder.yml&lt;/code&gt;, if not present you will
need to pass the configuration path to the conf file with the argument
&lt;code&gt;-config.file&lt;/code&gt; or &lt;code&gt;--config.file&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ladder -config.file=/etc/ladder/conf.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;listen-address&#34;&gt;Listen address&lt;/h2&gt;

&lt;p&gt;When running ladder by default will listen on &lt;code&gt;0.0.0.0:9094&lt;/code&gt; but you can override
this using &lt;code&gt;-listen.address&lt;/code&gt; or &lt;code&gt;--listen.address&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ladder -listen.address=&amp;quot;127.0.0.1:9092&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;debug&#34;&gt;Debug&lt;/h2&gt;

&lt;p&gt;You can run ladder in debug mode using the &lt;code&gt;-debug&lt;/code&gt; or &lt;code&gt;--debug&lt;/code&gt; flag, this
will print debug messages and also register dummy blocks so you can use them
to fake inputs and arrangements&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ladder -config.file=/etc/ladder/conf.yml -debug
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dry-run&#34;&gt;Dry run&lt;/h2&gt;

&lt;p&gt;You can run ladder in dy run mode using the &lt;code&gt;-dry.run&lt;/code&gt; or &lt;code&gt;--dry.run&lt;/code&gt; flag, this
will gather and arrange as a regular run but will omit the final step of
scaling up or down wo you can test your logic before deplying 100000 machines
and closing your company because of bankrupt&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ladder -config.file=/etc/ladder/conf.yml -dry.run
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;json-logger&#34;&gt;Json logger&lt;/h2&gt;

&lt;p&gt;By default ladder will log in text format, but in production when you use systems like
Elastic search, json is better because of the indexing, for this Ladder can log in
json just running with &lt;code&gt;-json.log&lt;/code&gt; or &lt;code&gt;--json.log&lt;/code&gt; flag.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ladder -config.file=/etc/ladder/conf.yml -json.log
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scalers</title>
      <link>https://themotion.github.io/ladder/blocks/scalers/</link>
      <pubDate>Sun, 13 Nov 2016 15:05:51 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/blocks/scalers/</guid>
      <description>

&lt;h2 id=&#34;dummy&#34;&gt;Dummy&lt;/h2&gt;

&lt;p&gt;Dummy scaler will return changed or not if the current quantity is same/different
of the new quantity, if different it will be the new current&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options&#34;&gt;Options:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wait_duration&lt;/code&gt;: The time to wait when waiting after scaling, by default &lt;code&gt;0ms&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scale:
  kind: dummy
  config:
    wait_duration: 5s
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Warning&lt;/p&gt;
&lt;p&gt;Only used for testing&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;stdout&#34;&gt;Stdout&lt;/h2&gt;

&lt;p&gt;Dummy scaler will return changed or not if the current quantity is same/different
of the new quantity, if different it will be the new current and will put a message
with the action made (upscale or downscale)&lt;/p&gt;

&lt;h3 id=&#34;name-1&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-1&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;message_prefix&lt;/code&gt;: The prefix for the messages&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scale:
  kind: stdout
  config:
    message_prefix: &amp;quot;[SCALER]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;auto-scaling-group&#34;&gt;Auto scaling group&lt;/h2&gt;

&lt;p&gt;Auto scaling group scaler will set the desired instances of the group to a the
new input, if the new quantity is the same as the current it will do nothing.&lt;/p&gt;

&lt;h3 id=&#34;name-2&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aws_autoscaling_group&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-2&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aws_region&lt;/code&gt;: The AWS region where the auto scaling group lives&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_scaling_group_name&lt;/code&gt;: The name of the autoscalingr group&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale_up_wait_duration&lt;/code&gt;: The time to wait after scaling up (to give time to the machines to stabilize)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale_down_wait_duration&lt;/code&gt;: The time to wait after scaling down&lt;/li&gt;
&lt;li&gt;&lt;code&gt;force_min_max&lt;/code&gt;: boolean that will set the min and max instances properties on the asg if true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt;:If an instance has been running for N minutes in the last hour and this time is higher than
the minutes reminaing in this setting for the current running hour then the instance can be downscaled. Example:
&lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt; is 10m, we have 10 instances, now want 5, 2 of them have been running in the last running hour for
50m or more and 8 for less than 50m, the scaler will set 8 instances and not 5, because only 2 meet the requirements of &amp;gt;=50m
running.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_no_downscale_rch_limit&lt;/code&gt;: The maximum times the filter refering to &lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt; didn&amp;rsquo;t downscale any
number, after this maximum times the filter will not activate and will downscale as it didn&amp;rsquo;t apply any filtering&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;scale_up_wait_duration&lt;/code&gt; or &lt;code&gt;scale_down_wait_duration&lt;/code&gt; are not defined, the scaler will wait until the desired
number of scaled instnaces met the running instances on the ASG&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt; is set to &lt;code&gt;0[smh]&lt;/code&gt; or is missing, it will be disabled&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt; logic doesn&amp;rsquo;t downscale any instance for &lt;code&gt;max_no_downscale_rch_limit&lt;/code&gt; opt iterations, it will downscale to the desired ones
no matter running time of the instances, this way if there are problems with the timing calculation, pace check or whatever, it will continue downscaling as a regular iteration&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;AWS invoices for a full hour, &lt;code&gt;remaining_closest_hour_limit_duration&lt;/code&gt; will enable a way of maximizing the use of scaled instances,
only downscaling to the number of instances required by the limit enables the &lt;a href=&#34;http://docs.aws.amazon.com/autoscaling/latest/userguide/as-instance-termination.html#default-termination-policy&#34;&gt;downscale policies&lt;/a&gt; of AWS.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;It will need &lt;code&gt;autoscaling:UpdateAutoScalingGroup&lt;/code&gt; AWS permission policy, for example:&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;Version&amp;quot;:&amp;quot;2012-10-17&amp;quot;,
   &amp;quot;Statement&amp;quot;:[  
      {  
         &amp;quot;Action&amp;quot;:&amp;quot;autoscaling:UpdateAutoScalingGroup&amp;quot;,
         &amp;quot;Resource&amp;quot;:&amp;quot;*&amp;quot;,
         &amp;quot;Effect&amp;quot;:&amp;quot;Allow&amp;quot;
      }
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scale:
  kind: aws_autoscaling_group
  config:
    aws_region: &amp;quot;us-west-2&amp;quot;
    auto_scaling_group_name: &amp;quot;slok-ECSAutoScalingGroup-1PNI4RX8BD5XU&amp;quot;  
    scale_up_wait_duration: 5m
    scale_down_wait_duration: 15s
    force_min_max: true
    remaining_closest_hour_limit_duration: 10m
    max_no_downscale_rch_limit: 180

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ecs-service&#34;&gt;ECS service&lt;/h2&gt;

&lt;p&gt;ECS service scaler will set the number of desired instances of an ECS service.
if the new quantity is the same as the current it will do nothing,&lt;/p&gt;

&lt;h3 id=&#34;name-3&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aws_ecs_service&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-3&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aws_region&lt;/code&gt;: The AWS region where the auto scaling group lives&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster_name&lt;/code&gt;: The name of the ECS cluster&lt;/li&gt;
&lt;li&gt;&lt;code&gt;service_name&lt;/code&gt;: The name of the service in the ECS cluster&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;requirements-1&#34;&gt;Requirements&lt;/h3&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;It will need &lt;code&gt;ecs:UpdateService&lt;/code&gt; AWS permission policy, for example:&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{  
   &amp;quot;Version&amp;quot;:&amp;quot;2012-10-17&amp;quot;,
   &amp;quot;Statement&amp;quot;:[  
      {  
         &amp;quot;Action&amp;quot;:&amp;quot;ecs:UpdateService&amp;quot;,
         &amp;quot;Resource&amp;quot;:&amp;quot;*&amp;quot;,
         &amp;quot;Effect&amp;quot;:&amp;quot;Allow&amp;quot;
      }
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-3&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scale:
  kind: aws_ecs_service
  config:
    aws_region: us-west-2
    cluster_name: slok-ECSCluster1-15OBYPKBNXIO6
    service_name: alertmanager
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Filters</title>
      <link>https://themotion.github.io/ladder/blocks/filters/</link>
      <pubDate>Sun, 13 Nov 2016 15:05:48 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/blocks/filters/</guid>
      <description>

&lt;h2 id=&#34;dummy&#34;&gt;Dummy&lt;/h2&gt;

&lt;p&gt;Dummy filterer will return a concrete value&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options&#34;&gt;Options&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;filters:
  - kind: dummy
    config:
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Warning&lt;/p&gt;
&lt;p&gt;Only used for testing&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;limit&#34;&gt;Limit&lt;/h2&gt;

&lt;p&gt;Limit filterer will restrict the scalign value to the max and min configured limits&lt;/p&gt;

&lt;h3 id=&#34;name-1&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-1&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max&lt;/code&gt;: The max value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min&lt;/code&gt;: The min value&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;filters:
  - kind: limit
    config:
      max: 10
      min: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ecs-running-tasks&#34;&gt;ECS running tasks&lt;/h2&gt;

&lt;p&gt;ECS running tasks filter will check how many tasks are pending by the ECS scheduler on a given
cluster, if this number exceeds the desired one then it will break the filters chain and set
the autoscaling to the current number.&lt;/p&gt;

&lt;h3 id=&#34;name-2&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ecs_running_tasks&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-2&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aws_region&lt;/code&gt;: String that contains the target ECS cluster region&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster_name&lt;/code&gt;: String that contains the name of the target ECS cluster&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_pending_tasks_allowed&lt;/code&gt;: integer that describes the maximum number of allowed not running tasks (or pending tasks)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_checks&lt;/code&gt;: Number of failed checks failing before continuing with a regular scalation besides the last check
(if max checks is 0 then its disabled)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error_on_max_checks&lt;/code&gt;: Boolean, when max checks is triggered instead of scaling as a regular iteration besides of the
of the result it will return an error and stop this current iteration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;when&lt;/code&gt;: string (enum) can be &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;scale_up&lt;/code&gt; or &lt;code&gt;scale_down&lt;/code&gt; this will say when the filter will be applied&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;filters:
  - kind: ecs_running_tasks
    config:
      aws_region: us-west-2
      cluster_name: slok-ECSCluster1-15OBYPKBNXIO6
      max_pending_tasks_allowed: 2
      max_checks: 5
      error_on_max_checks: false
      when: scale_down
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scaling-kind-interval&#34;&gt;Scaling kind interval&lt;/h2&gt;

&lt;p&gt;scaling kind iternval will allow or not scaling if the scaling mode has been
active for the configured duration. for example if you want to scaleup after 30 seconds
The autoscaler will need to be in scaleup for more than 30 seconds without interruption
(this is changing scaling mode), this allows us to omit spikes for the interval
we want&lt;/p&gt;

&lt;h3 id=&#34;name-3&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;scaling_kind_interval&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-3&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scale_up_duration&lt;/code&gt;: The duration of the scaling up mode need for triggering&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale_down_duration&lt;/code&gt;: The duration of the scaling down mode need for triggering&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;filters:
  - kind: scaling_kind_interval
    config:
      scale_up_duration: 30s
      scale_down_duration: 1m

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Solvers</title>
      <link>https://themotion.github.io/ladder/blocks/solvers/</link>
      <pubDate>Sun, 13 Nov 2016 15:05:43 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/blocks/solvers/</guid>
      <description>

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You only will need a solver if you have multiple inputters, if not it will be
ignored although there is configured on the file&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;dummy&#34;&gt;Dummy&lt;/h2&gt;

&lt;p&gt;Dummy solver will return the sum of all the inputs&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options&#34;&gt;Options&lt;/h3&gt;

&lt;p&gt;No options&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;solve:
  kind: dummy
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Warning&lt;/p&gt;
&lt;p&gt;Only used for testing&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;bound&#34;&gt;Bound&lt;/h2&gt;

&lt;p&gt;Bound solver will return the max or min of all the received inputters quantity.&lt;/p&gt;

&lt;h3 id=&#34;name-1&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-1&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kind&lt;/code&gt;: Can be &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;solve:
  kind: bound
  config:
    kind: max
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Arrangers</title>
      <link>https://themotion.github.io/ladder/blocks/arrangers/</link>
      <pubDate>Sun, 13 Nov 2016 15:05:35 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/blocks/arrangers/</guid>
      <description>

&lt;h2 id=&#34;dummy&#34;&gt;Dummy&lt;/h2&gt;

&lt;p&gt;Dummy gatherer always will return a constant quantity&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;quantity&lt;/code&gt;: The quantity to return always&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;arrange:
  kind: dummy
  config:
    quantity: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Warning&lt;/p&gt;
&lt;p&gt;Only used for testing&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;in-list&#34;&gt;In list&lt;/h2&gt;

&lt;p&gt;In list arranger will arrange a new quantity to scale up/down based on two lists
When the quantity received is in &lt;code&gt;match_upscale&lt;/code&gt; list it will scale the current
quantity by the &lt;code&gt;match_up_magnitude&lt;/code&gt; percent. The same for the downscale.&lt;/p&gt;

&lt;p&gt;For example scaling up 100 by a magnitude of 50 it will result in 150. Downscale
by 20 will result in 80&lt;/p&gt;

&lt;h3 id=&#34;name-1&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;in_list&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-1&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;match_downscale&lt;/code&gt;: The downscale list of quantities (numbers only allowed)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match_upscale&lt;/code&gt;: The upscale list of quantities (numbers only allowed)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match_up_magnitude&lt;/code&gt;: The upscale magnitude (scalation of the current by %)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match_down_magnitude&lt;/code&gt;:  The downscale magnitude (scalation of the current by %)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;arrange:
  kind: in_list
  config:
    match_downscale: [0, 2, 4, 6, 8]
    match_upscale: [1, 2, 5, 7, 9]
    match_up_magnitude:   200
    match_down_magnitude: 50
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;constant-factor&#34;&gt;Constant factor&lt;/h2&gt;

&lt;p&gt;Constant factor will arrange a new quantity based on a constant factor division.
For example an input of 500 with a constant factor of 10 will result on a 50
quantity. When a floating point result is arranged it will round
the result up/down based on the &lt;code&gt;round_type&lt;/code&gt; option&lt;/p&gt;

&lt;h3 id=&#34;name-2&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;constant_factor&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-2&#34;&gt;Options:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;factor&lt;/code&gt;: The factor for the division of the input&lt;/li&gt;
&lt;li&gt;&lt;code&gt;round_type&lt;/code&gt;: The type of rounding, available ones:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ceil&lt;/code&gt;: Rounds up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor&lt;/code&gt;: Rounds down&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;arrange:
  kind: constant_factor
  config:
    factor: 10
    round_type: &amp;quot;ceil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;threshold&#34;&gt;Threshold&lt;/h2&gt;

&lt;p&gt;Threshold will arrange a new quantity based on upper ond lower thresholds, it
will scale up &amp;amp; down based on the percent of the current cuantity until the input
gets between the 2 thresholds, it can scale up and down in a different way.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;By default this arranger will scale up when the value received is above &lt;code&gt;scaleup_threshold&lt;/code&gt;, and scale down when the value
is below &lt;code&gt;scaledown_threshold&lt;/code&gt;, to invert this and scale up when the value is below &lt;code&gt;scaleup_threshold&lt;/code&gt; and scale down when the
value is greater than &lt;code&gt;scaledown_threshold&lt;/code&gt;, you need to use the &lt;code&gt;inverse&lt;/code&gt; setting&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;name-3&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;threshold&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-3&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scaleup_threshold&lt;/code&gt;: The threshold to start scaling up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaledown_threshold&lt;/code&gt;: The threshold to start scaling up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaleup_percent&lt;/code&gt;: The percent of current value that will be add when scaling up is triggered&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaledown_percent&lt;/code&gt;: The percent of current value that will be substract when scaling down is triggered&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaleup_max_quantity&lt;/code&gt;: The max quantity of the scaling up value (the delta get from &lt;code&gt;scaleup_percent&lt;/code&gt; with current value)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaledown_max_quantity&lt;/code&gt;: The max quantity of the scaling down value (the delta get from &lt;code&gt;scaledown_percent&lt;/code&gt; with current value)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaleup_min_quantity&lt;/code&gt;: The min quantity of the scaling up value (the delta get from &lt;code&gt;scaleup_percent&lt;/code&gt; with current value)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaledown_min_quantity&lt;/code&gt;: The min quantity of the scaling down value (the delta get from &lt;code&gt;scaledown_percent&lt;/code&gt; with current value)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inverse&lt;/code&gt;: By default this arranger will scale up when the value received is above the &lt;code&gt;scaleup_threshold&lt;/code&gt; threshold and will scale down when the value is below &lt;code&gt;scaledown_threshold&lt;/code&gt;, if inverse is true it will invert this and will scaleup when the value is below
the threshold and scale down when is above the threshold&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-3&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;arrange:
  kind: threshold
  config:
    scaleup_threshold: 80
    scaledown_threshold: 70
    scaleup_percent: 10
    scaledown_percent: 10
    scaleup_max_quantity: 30
    scaledown_max_quantity: 10
    scaleup_min_quantity: 2
    scaledown_min_quantity: 1
    inverse: false
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;To upscale or downscale with a fixed absolute value instead of percent you can set to 0 (or omit) scaling percents and
the min and max of the scaling mode to a fixed value&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;example-with-fixed-value&#34;&gt;Example with fixed value&lt;/h3&gt;

&lt;p&gt;Downscale with a fixed value of 2 and upscale with a fixed value of 5&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;arrange:
  kind: threshold
  config:
    scaleup_threshold: 80
    scaledown_threshold: 70
    #scaleup_percent: 0
    #scaledown_percent: 0
    scaleup_max_quantity: 5
    scaleup_min_quantity: 5
    scaledown_max_quantity: 2
    scaledown_min_quantity: 2
    innverse: false
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;With this arranger (and the &lt;a href=&#34;https://themotion.github.io/ladder/blocks/filters/#scaling-kind-interval&#34;&gt;&lt;code&gt;scaling_kind_interval&lt;/code&gt;&lt;/a&gt; filterer) we met the requirements for a dynamic and independent growth/reduction
like the described on Netflix tech post: &lt;a href=&#34;http://techblog.netflix.com/2012/01/auto-scaling-in-amazon-cloud.html&#34;&gt;&lt;code&gt;Auto scaling in amazon cloud&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Gatherers</title>
      <link>https://themotion.github.io/ladder/blocks/gatherers/</link>
      <pubDate>Sun, 13 Nov 2016 15:05:29 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/blocks/gatherers/</guid>
      <description>

&lt;h2 id=&#34;dummy&#34;&gt;Dummy&lt;/h2&gt;

&lt;p&gt;Dummy gatherer always will return a constant quantity&lt;/p&gt;

&lt;h3 id=&#34;name&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;quantity&lt;/code&gt;: The quantity to return always&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;gather:
  kind: dummy
  config:
    quantity: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Warning&lt;/p&gt;
&lt;p&gt;Only used for testing&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;random&#34;&gt;Random&lt;/h2&gt;

&lt;p&gt;Random gatherer will return a random number between a max and min bounds&lt;/p&gt;

&lt;h3 id=&#34;name-1&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;random&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-1&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max_limit&lt;/code&gt;: The max limit of the random (not included)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min_limit&lt;/code&gt;: The min limit of the random (included)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;gather:
  kind: random
  config:
    max_limit: 10
    min_limit: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sqs-property&#34;&gt;SQS property&lt;/h2&gt;

&lt;p&gt;SQS gatherer will return the quantity of the number of messages of a queue, this
number can be one of the available SQS prperties&lt;/p&gt;

&lt;h3 id=&#34;name-2&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aws_sqs&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-2&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;queue_url&lt;/code&gt;: The SQS queue URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;queue_property&lt;/code&gt;: The property to get the message number, can be one of these 3:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ApproximateNumberOfMessages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApproximateNumberOfMessagesNotVisible&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApproximateNumberOfMessagesDelayed&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aws_region&lt;/code&gt;: The region of AWS where the SQS queue lives&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;gather:
  kind: aws_sqs
  config:
    queue_url: &amp;quot;https://sqs.us-west-2.amazonaws.com/016386521566/slok-render-jobs&amp;quot;
    queue_property: &amp;quot;ApproximateNumberOfMessages&amp;quot;
    aws_region: &amp;quot;us-west-2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cloudwatch-metric&#34;&gt;Cloudwatch metric&lt;/h2&gt;

&lt;p&gt;Cloudwatchmetric gatherer will return a current metric of a given query for the
last minute aggregation, this let us know curren values (approx.) about AWS metrics.&lt;/p&gt;

&lt;h3 id=&#34;name-3&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aws_cloudwatch_metric&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-3&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aws_region&lt;/code&gt;: The region of AWS where the cloudwatch metrics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;metric_name&lt;/code&gt;: The name of the metric(&lt;code&gt;CPUReservation&lt;/code&gt;, &lt;code&gt;CPUCreditBalance&lt;/code&gt;, &lt;code&gt;DiskWriteBytes&lt;/code&gt;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;namespace&lt;/code&gt;: The namespace of the metric (&lt;code&gt;AWS/ELB&lt;/code&gt;, &lt;code&gt;AWS/EC2&lt;/code&gt;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;statistic&lt;/code&gt;: The statistic type of the metric. Check them at:     &lt;a href=&#34;https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Statistic&#34;&gt;https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Statistic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unit&lt;/code&gt;: The unit type of the metric, Check them at:   &lt;a href=&#34;https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit&#34;&gt;https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offset&lt;/code&gt;: 0 or negative time duration to apply to the metrics query, for example &lt;code&gt;-30s&lt;/code&gt; will get the metrics from -1&amp;rsquo;30&amp;rdquo; to -30&amp;rdquo; metrics from now&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dimensions&lt;/code&gt;: dimensions are like prometheus labels, is a list of dicts having &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; with this the metric wil be filtered&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-3&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;gather:
  kind: aws_cloudwatch_metric
  config:
    aws_region: &amp;quot;us-west-2&amp;quot;
    metric_name: &amp;quot;CPUReservation&amp;quot;
    namespace: &amp;quot;AWS/ECS&amp;quot;
    statistic: &amp;quot;Maximum&amp;quot;
    unit: &amp;quot;Percent&amp;quot;
    offset: &amp;quot;-30s&amp;quot;
    dimensions:
    - name: &amp;quot;ClusterName&amp;quot;
      value: &amp;quot;slok-ECSCluster1-15OBYPKBNXIO6&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prometheus-metric&#34;&gt;Prometheus metric&lt;/h2&gt;

&lt;p&gt;Prometheus metric gatherer is one of the most powerful gatherers, not because of the gatherer itself, but for
the amazing Prometheus query API. This gatherer should work with single sample vectors, other type of results
from Prometheus will error, for example a vector with length greater than 1 or a Matrix result.&lt;/p&gt;

&lt;p&gt;Prometheus gatherer accepts different prometheus so it can fallback to a different prometheus to get the metric.
&lt;a href=&#34;https://prometheus.io/docs/introduction/faq/#can-prometheus-be-made-highly-available?&#34;&gt;HA Prometheus&lt;/a&gt; infrastructure is usually made by 2 equal prometheis that are independent one each other&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You should query precalculated metrics (recording rules), this will speed up the query and will be more
readable&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;name-4&#34;&gt;Name&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;prometheus_metric&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;options-4&#34;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addresses&lt;/code&gt;: The addresses of the prometheus endpoint&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query&lt;/code&gt;: The query that will be send to prometheus&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-4&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;gather:
  kind: prometheus_metric
  config:
    addresses:
      - http://prometheus.prod.bi.themotion.lan
      - http://prometheus2.prod.bi.themotion.lan
      - http://prometheus3.prod.bi.themotion.lan
    query: max(service:container_memory_usage:percent{service=&amp;quot;prometheus&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Blocks</title>
      <link>https://themotion.github.io/ladder/concepts/blocks/</link>
      <pubDate>Sun, 13 Nov 2016 10:47:06 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/concepts/blocks/</guid>
      <description>

&lt;p&gt;As we said previously, Ladder can have multiple autoscalers, and each autoscaler is
made by differet kind of blocks, these blocks are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Inputters&lt;/strong&gt;: The ones that gather data and make a decision&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solvers&lt;/strong&gt;: The ones that take multiple inputters result and take one of them&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filters&lt;/strong&gt;: The ones that take the Solver result and apply some kind of logic based on the solver result&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scalers&lt;/strong&gt;: The ones that scale based on all the previous flow result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let take a look at Ladder&amp;rsquo;s architecture first and then try to explain each of the parts&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://themotion.github.io/ladder/img/architecture.png&#34; alt=&#34;Ladder architecture&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;inputter&#34;&gt;Inputter&lt;/h2&gt;

&lt;p&gt;An inputter is a a composite block, is made of a gatherer and an arranger.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;An autoscaler can have multiple inputters.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;gatherer&#34;&gt;Gatherer&lt;/h2&gt;

&lt;p&gt;This kind of block is the one that will grab the values form external sources, is the
start of the autoscaler cycle.&lt;/p&gt;

&lt;p&gt;Some kind of gatherers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The number of messages in a queue&lt;/li&gt;
&lt;li&gt;The CPU % used&lt;/li&gt;
&lt;li&gt;The mean request latency&lt;/li&gt;
&lt;li&gt;The remaining free size of a disk&lt;/li&gt;
&lt;li&gt;The temperature of a room&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arranger&#34;&gt;Arranger&lt;/h2&gt;

&lt;p&gt;The arranger block is the one that makes the decisions based on the gatherer data. In order
to make a decision and return a valid quantity for the scaler block, the arranger has the gatherer data
and the current quantity of the scaler (or scaler target).&lt;/p&gt;

&lt;p&gt;In other words, will take the gatherer data, the current scaler target data, apply some logic and return a result
that can be used by the scaler to set the arranged value on the scaler target.&lt;/p&gt;

&lt;p&gt;Some kind of arrangers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the current input is greater that a quantity during X minutes then increment by 10% the current scaler target quantity&lt;/li&gt;
&lt;li&gt;If the input is equal to a quantity then set the quantity to 0&lt;/li&gt;
&lt;li&gt;Take the current input data and add 5&lt;/li&gt;
&lt;li&gt;Take the current input data and divide by a constant value.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;The arranger of an inputter can be empty (this means that the gathered value will be passed transparently to the solver)&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;solver&#34;&gt;Solver&lt;/h2&gt;

&lt;p&gt;As we said above, we can have multiple inputters, but at the end the autoscaler only can set one correct value on the
scaling target, the solver is the one that takes all this inputters result and apply some logic so it finally returns
one single quantity result.&lt;/p&gt;

&lt;p&gt;Some kind of solvers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The summatory of all inputters&lt;/li&gt;
&lt;li&gt;The max or min of all inputters&lt;/li&gt;
&lt;li&gt;The first of all the inputters&lt;/li&gt;
&lt;li&gt;A random of all the inputters&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If only one inputter is configured, the solver will be ignored&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;filterer-filter&#34;&gt;Filterer (filter)&lt;/h2&gt;

&lt;p&gt;Filterers or filters is a kind of block that is configured as an ordered list or chain.
Each filter will be applied in order and can change the input of the next filter to apply,
When executing a filter it will receive the arranged value by the solver and the current value of
the scaling target, after aplyign the filter logic, this will return a result, and a flag
specifying if the filter breaks the whole filter chain or not.&lt;/p&gt;

&lt;p&gt;With this process we can validate, change or error multiple times the received value, before
the scaler scales the target&lt;/p&gt;

&lt;p&gt;Some kind of filters could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A limiting filterer that doesn&amp;rsquo;t allow values more or lesser than the defined values&lt;/li&gt;
&lt;li&gt;A filter that breaks the chain without altering the current value if a check with a 3rd party service doesn&amp;rsquo;t return correctly&lt;/li&gt;
&lt;li&gt;A interval filterer that allows scaling if the autoscaler has been in scaleup mode after 1 minute and allow downscale if the mode has been in downscale mode for 5 minutes&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;The order of the filterers chain is very important&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;scaler&#34;&gt;Scaler&lt;/h2&gt;

&lt;p&gt;An scaler is the final part of an autoscaler, this kind of blokc is the one that will trigger the scaling on the
scaling target with the received quantity (or if it didn&amp;rsquo;t change then don&amp;rsquo;t scale).&lt;/p&gt;

&lt;p&gt;Some kind of scaler could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The desired number of instances in an AWS auto scaling group&lt;/li&gt;
&lt;li&gt;The number of GBs asigned to an instance&lt;/li&gt;
&lt;li&gt;The asigned Memory to a docker container&lt;/li&gt;
&lt;li&gt;The number of replicas of a Kubernetes pod&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Autoscaler</title>
      <link>https://themotion.github.io/ladder/concepts/autoscaler/</link>
      <pubDate>Sun, 13 Nov 2016 10:47:00 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/concepts/autoscaler/</guid>
      <description>

&lt;p&gt;A ladder autoscaler is built with different kind of &lt;a href=&#34;https://themotion.github.io/ladder/concepts/blocks/&#34;&gt;blocks&lt;/a&gt;,
in the next section you can read the difference between these different kind of blocks.&lt;/p&gt;

&lt;h2 id=&#34;flow&#34;&gt;Flow&lt;/h2&gt;

&lt;p&gt;The flow of a Ladder autoscaler is very simple, at a high overview its as simple as this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://themotion.github.io/ladder/img/flow.png&#34; alt=&#34;Ladder flow&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pull-based-system&#34;&gt;Pull based system&lt;/h2&gt;

&lt;p&gt;Ladder autoscalers are based on pull system, this means that an autoscaler will
check the state on regular intervals. Ladder philosophy is not to stay listening to some event
that triggers the scaling flow. Ladder phisolophy is to be automatic and autonomous&lt;/p&gt;

&lt;h2 id=&#34;multiple-autoscalers&#34;&gt;Multiple autoscalers&lt;/h2&gt;

&lt;p&gt;Ladder runs multiple autoscalers at once, in different invervals based on the configuration,
for example a Ladder instance could be running these autoscalers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cluster autoscaler that will check the state each 5 minutes&lt;/li&gt;
&lt;li&gt;Service X autoscaler taht willcheck the state each 1 minute&lt;/li&gt;
&lt;li&gt;Service Y autoscaler that will check the state each 10 minutes&lt;/li&gt;
&lt;li&gt;Size of a disk that will check the state each hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These autoscalers are being check concurrently at different intervals by a single Ladder instance,
you can set any number of Autoscalers for each Ladder instance.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You can set multiple Ladder instances with different autoscalers on each one&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Installing</title>
      <link>https://themotion.github.io/ladder/introduction/installing/</link>
      <pubDate>Sun, 13 Nov 2016 10:25:52 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/introduction/installing/</guid>
      <description>

&lt;p&gt;Ladder is written in Go, this makes it very portable, Go gives us the power
of sharing a single binary, easy and fast.&lt;/p&gt;

&lt;h2 id=&#34;precompiled-binary&#34;&gt;Precompiled binary&lt;/h2&gt;

&lt;p&gt;TODO (when first version uploaded)&lt;/p&gt;

&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;

&lt;p&gt;An official Docker image is available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker pull themotion/ladder
$ docker run -p 9094:9094 themotion/ladder
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;building-from-source&#34;&gt;Building from source&lt;/h2&gt;

&lt;p&gt;You can build from source using go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/themotion/ladder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also build cloning the repository:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/themotion/ladder.git $GOPATH/src/github.com/themotion/ladder
$ cd $GOPATH/src/github.com/themotion/ladder
$ make build_release
$ ./bin/ladder --help
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://themotion.github.io/ladder/introduction/overview/</link>
      <pubDate>Sun, 13 Nov 2016 10:20:46 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/introduction/overview/</guid>
      <description>

&lt;h2 id=&#34;what-is-ladder-for&#34;&gt;What is Ladder for?&lt;/h2&gt;

&lt;p&gt;Ladder is a simple and flexible general purpose autoscaler.&lt;/p&gt;

&lt;p&gt;The idea behind Ladder is to autoscale anything configuring and combining reusable &lt;a href=&#34;https://themotion.github.io/ladder/concepts/blocks/&#34;&gt;blocks&lt;/a&gt;
of different types in a yaml file. These blocks are flexible and easy to extend, so anyone can use or develop any kind of scaling targets,
policies or inputs.&lt;/p&gt;

&lt;p&gt;Some examples that Ladder can do at this moment:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get number of messages in a &lt;a href=&#34;https://aws.amazon.com/sqs/&#34;&gt;SQS queue&lt;/a&gt;, apply a constant factor to this input, then use this quantity to upscale or downscale the &lt;a href=&#34;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Instances.html&#34;&gt;EC2 machines&lt;/a&gt; of an &lt;a href=&#34;http://docs.aws.amazon.com/autoscaling/latest/userguide/AutoScalingGroup.html&#34;&gt;AWS AutoscalingGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get the latency of a service from a &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt; metric, if this latency is greater than 800ms, add one more instance to the actual number of instances of that service running on &lt;a href=&#34;https://aws.amazon.com/ecs/&#34;&gt;ECS&lt;/a&gt;,
if is less than 200ms remove one instance to the running ones instead.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You want to start using it? Jump to the &lt;a href=&#34;https://themotion.github.io/ladder/introduction/quickstart/&#34;&gt;tutorial&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&#34;what-is-not-ladder-for&#34;&gt;What is not Ladder for?&lt;/h2&gt;

&lt;p&gt;Ladder is not for manual scaling, to ensure that an scaling target is always
at some quantity, or using Ladders metric to monitor the status of the target.
Although Ladder could do this, is not the main objective and depending on the
kind of target, there are other better tools for this purpouses out there.&lt;/p&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Very flexible and configurable&lt;/li&gt;
&lt;li&gt;Simple, light and fast&lt;/li&gt;
&lt;li&gt;Reliable&lt;/li&gt;
&lt;li&gt;Easy to configure and extend&lt;/li&gt;
&lt;li&gt;Metrics ready (Prometheus)&lt;/li&gt;
&lt;li&gt;Easy to deploy and set up running&lt;/li&gt;
&lt;li&gt;Tons of third party blocks ready to use (AWS, Prometheus&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;future&#34;&gt;Future&lt;/h2&gt;

&lt;p&gt;We want to add more blocks to the ones that Ladder provides by default (ECS &amp;amp; EC2 ASG), for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inputs:

&lt;ul&gt;
&lt;li&gt;Get metrics from Datadog&lt;/li&gt;
&lt;li&gt;Get number of messages from Rabbitmq queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Filters:

&lt;ul&gt;
&lt;li&gt;Apply statistic prediction based on a metric, previous autoscaling result, etc&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scalers:

&lt;ul&gt;
&lt;li&gt;Kubernetes replicas&lt;/li&gt;
&lt;li&gt;Instance VMs on  GCE&lt;/li&gt;
&lt;li&gt;Azure virtual machines&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>